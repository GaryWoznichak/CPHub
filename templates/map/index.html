{% extends "base.html" %}
{% block content %}
<div class="container-fluid">
    <div class="map-header">
        <h2><i class="fas fa-map-marked-alt"></i> Device Map</h2>
        <div class="map-controls">
            <div class="status-legend">
                <span class="legend-item">
                    <span class="status-dot connected"></span> Online
                </span>
                <span class="legend-item">
                    <span class="status-dot pending"></span> Pending
                </span>
                <span class="legend-item">
                    <span class="status-dot disconnected"></span> Offline
                </span>
            </div>
        </div>
    </div>
   
    <!-- Map Container -->
    <div id="device-map" style="height: 70vh; width: 100%; border-radius: 8px;"></div>
   
    <!-- Device Info Panel -->
    <div id="device-info-panel" class="device-panel">
        <h4>Select a device on the map</h4>
        <p>Click any marker to view device details and controls.</p>
    </div>
</div>

<style>
.map-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding: 15px 0;
}
.map-header h2 {
    color: #ecf0f1;
    margin: 0;
}
.status-legend {
    display: flex;
    gap: 20px;
    color: #ecf0f1;
}
.legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
}
.status-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
}
.status-dot.connected { background-color: #27ae60; }
.status-dot.pending { background-color: #f39c12; }
.status-dot.disconnected { background-color: #95a5a6; } /* Changed to gray */

.device-panel {
    background: #34495e;
    border: 1px solid #2c3e50;
    border-radius: 8px;
    padding: 20px;
    margin-top: 20px;
    color: #ecf0f1;
}
.device-panel h4 {
    margin-top: 0;
    color: #3498db;
}
#device-map {
    border: 2px solid #2c3e50;
}

.custom-marker {
    background: none;
    border: none;
}
.marker-icon {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 3px solid white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    position: relative;
}
.connected .marker-icon {
    background-color: #27ae60;
    color: white;
}
.pending .marker-icon {
    background-color: #f39c12;
    color: white;
}

/* NEW: Gray disconnected with slash-through */
.disconnected .marker-icon {
    background-color: #95a5a6;
    color: white;
    position: relative;
}

.disconnected .marker-icon::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 10%;
    right: 10%;
    height: 2px;
    background-color: white;
    transform: translateY(-50%) rotate(45deg);
    z-index: 5;
}

/* Enhanced popup styling - cleaner layout */
.leaflet-popup-content-wrapper {
    background: #34495e !important;
    color: #ecf0f1 !important;
    border-radius: 8px !important;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3) !important;
    border: 1px solid #2c3e50 !important;
    padding: 0 !important;
}

.leaflet-popup-content {
    margin: 0 !important;
    padding: 0 !important;
    color: #ecf0f1 !important;
    font-family: inherit !important;
    width: auto !important;
}

.leaflet-popup-tip {
    background: #34495e !important;
    border: 1px solid #2c3e50 !important;
}

.leaflet-popup-close-button {
    color: #bdc3c7 !important;
    font-size: 16px !important;
    font-weight: bold !important;
    padding: 8px 12px !important;
    right: 8px !important;
    top: 8px !important;
    width: auto !important;
    height: auto !important;
    text-align: center !important;
}

.leaflet-popup-close-button:hover {
    color: #ecf0f1 !important;
    background: rgba(255,255,255,0.1) !important;
    border-radius: 4px;
}

.device-popup-card {
    background: #34495e;
    color: #ecf0f1;
    padding: 18px;
    min-width: 300px;
    border-radius: 8px;
    margin: 0;
}

.device-popup-header {
    margin-bottom: 15px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(255,255,255,0.1);
}

.device-popup-name {
    font-size: 1.1em;
    font-weight: 600;
    color: #ecf0f1;
    margin-bottom: 6px;
    line-height: 1.3;
}

.device-popup-type {
    font-size: 0.9em;
    color: #bdc3c7;
    text-transform: uppercase;
    font-weight: 500;
    margin: 0;
}

.device-popup-details {
    margin-bottom: 18px;
}

.device-popup-address {
    font-size: 0.9em;
    color: #ecf0f1;
    margin-bottom: 10px;
    line-height: 1.4;
    padding-left: 0;
}

.device-popup-model {
    font-size: 0.85em;
    color: #bdc3c7;
    margin: 0;
    padding-left: 0;
}

.device-popup-actions {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 8px;
    margin-top: 18px;
    padding-top: 15px;
    border-top: 1px solid rgba(255,255,255,0.1);
}

.popup-action-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
    padding: 10px 8px;
    background: #3498db;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.8em;
    font-weight: 600;
    transition: all 0.3s ease;
    text-decoration: none;
    min-height: 36px;
}

.popup-action-btn:hover {
    background: #2980b9;
    transform: translateY(-1px);
    color: white;
}

.popup-action-btn:active {
    transform: translateY(0);
}

.popup-action-btn.success {
    background: #27ae60 !important;
}

.popup-action-btn.error {
    background: #e74c3c !important;
}

.popup-action-btn:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    transform: none !important;
}

/* NEW: Red pulsing ring effect for recording devices */
.recording .marker-icon::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 60px;
    height: 60px;
    border: 3px solid #e74c3c;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    animation: pulse-ring-red 1.5s infinite;
    z-index: -1;
}

.recording .marker-icon::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 40px;
    height: 40px;
    border: 2px solid rgba(231, 76, 60, 0.6);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    animation: pulse-ring-red 1.5s infinite 0.5s;
    z-index: -1;
}

@keyframes pulse-ring-red {
    0% {
        transform: translate(-50%, -50%) scale(0.5);
        opacity: 1;
    }
    100% {
        transform: translate(-50%, -50%) scale(2);
        opacity: 0;
    }
}

/* NEW: Red flashing recording marker */
.recording .marker-icon {
    background-color: #e74c3c !important;
    animation: recording-flash-red 0.8s infinite;
    border-color: #fff !important;
    box-shadow: 0 4px 12px rgba(231, 76, 60, 0.8) !important;
    transform: scale(1.4) !important;
    z-index: 1000 !important;
    position: relative;
}

@keyframes recording-flash-red {
    0%, 50% {
        background-color: #e74c3c;
        box-shadow: 0 4px 12px rgba(231, 76, 60, 0.8), 0 0 0 8px rgba(231, 76, 60, 0.4);
        transform: scale(1.4);
    }
    51%, 100% {
        background-color: #c0392b;
        box-shadow: 0 4px 16px rgba(192, 57, 43, 1), 0 0 0 12px rgba(192, 57, 43, 0.2);
        transform: scale(1.5);
    }
}
</style>

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
// Device data from Flask
const devices = {{ devices | tojson }};

// Initialize map
const map = L.map('device-map').setView([40.7128, -74.0060], 10); // Default to NYC, we'll adjust

// Add tile layer (OpenStreetMap)
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Â© OpenStreetMap contributors'
}).addTo(map);

// Custom marker icons for different statuses
const markerIcons = {
    connected: L.divIcon({
        className: 'custom-marker connected',
        html: '<div class="marker-icon"></div>',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
    }),
    pending: L.divIcon({
        className: 'custom-marker pending',
        html: '<div class="marker-icon"></div>',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
    }),
    disconnected: L.divIcon({
        className: 'custom-marker disconnected',
        html: '<div class="marker-icon"></div>',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
    })
};

// Add marker styles
const markerCSS = `
<style>
.custom-marker {
    background: none;
    border: none;
}
.marker-icon {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 3px solid white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
}
.connected .marker-icon {
    background-color: #27ae60;
    color: white;
}
.pending .marker-icon {
    background-color: #f39c12;
    color: white;
}
.disconnected .marker-icon {
    background-color: #e74c3c;
    color: white;
}
</style>
`;
document.head.insertAdjacentHTML('beforeend', markerCSS);

// Function to get device type display name
function getDeviceTypeDisplay(locationType) {
    const typeMap = {
        'traffic_box': 'Traffic Control Box',
        'pump_station': 'Pump Station',
        'building': 'Building', // This was missing!
        'utility_pole': 'Utility Pole',
        'intersection': 'Street Intersection',
        'utility_station': 'Utility Station',
        'other': 'Other Location'
    };
    return typeMap[locationType] || 'Unknown Type'; // Changed fallback
}

// Create enhanced popup content
// Updated for your route structure
function createDevicePopup(device) {
    const address = device.address || device.location_name || 'Address not set';
    const locationType = device.location_type || 'other';
    
    return `
        <div class="device-popup-card">
            <div class="device-popup-header">
                <div class="device-popup-name">${device.device_name}</div>
                <div class="device-popup-type">${getDeviceTypeDisplay(locationType)}</div>
            </div>
            
            <div class="device-popup-details">
                <div class="device-popup-address">
                    <i class="fas fa-map-marker-alt" style="margin-right: 6px; color: #bdc3c7;"></i>
                    ${address}
                </div>
                <div class="device-popup-model">
                    <i class="fas fa-microchip" style="margin-right: 6px; color: #bdc3c7;"></i>
                    ${device.model_number || 'Model not specified'}
                </div>
            </div>
            
            <div class="device-popup-actions">
                <button class="popup-action-btn ping-btn" onclick="pingDeviceFromMap(${device.device_id}, '${device.ip_address}', this)">
                    <i class="fas fa-satellite-dish"></i>
                    <span>Ping</span>
                </button>
                
                <button class="popup-action-btn remote-btn" onclick="remoteAccessFromMap(${device.device_id}, '${device.ip_address}', ${device.port}, this)">
                    <i class="fas fa-external-link-alt"></i>
                    <span>Remote</span>
                </button>
                
                <button class="popup-action-btn edit-btn" onclick="editDeviceFromMap(${device.device_id})">
                    <i class="fas fa-edit"></i>
                    <span>Edit</span>
                </button>
            </div>
        </div>
    `;
}

// Add this new function for the edit button
function editDeviceFromMap(deviceId) {
    window.location.href = `/devices/${deviceId}/edit`;
}

// Ping device function (same as dashboard)
function pingDeviceFromMap(deviceId, deviceIp, button) {
    const originalContent = button.innerHTML;
    
    // Update button to show pinging state
    button.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span>Pinging...</span>';
    button.disabled = true;
    
    console.log(`Pinging device ${deviceId} at ${deviceIp} from map`);
    
    // Ping the device
    fetch(`/api/devices/${deviceId}/ping`)
        .then(response => response.json())
        .then(data => {
            console.log('Ping response:', data);
            
            if (data.success) {
                // Show success state
                button.innerHTML = '<i class="fas fa-check"></i><span>Online</span>';
                button.classList.add('success');
                
                // Show result in popup or alert
                setTimeout(() => {
                    alert(`ðŸŸ¢ Device is reachable!\n\nIP: ${data.ip_address}\nResponse Time: ${data.response_time}\nStatus: ${data.status}`);
                }, 500);
            } else {
                // Show error state
                button.innerHTML = '<i class="fas fa-times"></i><span>Failed</span>';
                button.classList.add('error');
                
                setTimeout(() => {
                    alert(`ðŸ”´ Ping failed!\n\nIP: ${data.ip_address}\nError: ${data.error}`);
                }, 500);
            }
        })
        .catch(error => {
            console.error('Ping error:', error);
            button.innerHTML = '<i class="fas fa-exclamation-triangle"></i><span>Error</span>';
            button.classList.add('error');
            setTimeout(() => {
                alert(`âš ï¸ Network error: ${error.message}`);
            }, 500);
        })
        .finally(() => {
            // Restore button after 2 seconds
            setTimeout(() => {
                button.innerHTML = originalContent;
                button.disabled = false;
                button.classList.remove('success', 'error');
            }, 2000);
        });
}

// Remote access function (same as dashboard)
function remoteAccessFromMap(deviceId, deviceIp, devicePort, button) {
    // First, check if this device has a tunnel connection available
    fetch(`/api/devices/${deviceId}/connection_info`)
        .then(response => response.json())
        .then(data => {
            let deviceUrl;
            let connectionType;
            
            if (data.tunnel_port && data.tunnel_status === 'connected') {
                // Use tunnel connection
                deviceUrl = `/proxy/${deviceId}/`;
                connectionType = 'tunnel';
                console.log(`ðŸ”— Using tunnel connection to device ${deviceId} via port ${data.tunnel_port} from map`);
            } else if (deviceIp && deviceIp !== 'N/A') {
                // Use direct IP connection
                deviceUrl = `http://${deviceIp}:${devicePort}`;
                connectionType = 'direct';
                console.log(`ðŸ”— Using direct IP connection to device ${deviceId} at ${deviceIp} from map`);
            } else {
                alert('âŒ No connection method available for this device');
                return;
            }
            
            console.log(`Opening remote access to device ${deviceId} at ${deviceUrl} (${connectionType}) from map`);
            
            // Open in new tab
            const newTab = window.open(deviceUrl, '_blank');
            
            // Check if popup was blocked
            if (!newTab || newTab.closed || typeof newTab.closed == 'undefined') {
                alert(`ðŸ”’ Popup blocked!\n\nPlease allow popups for this site, or manually navigate to:\n${deviceUrl}`);
                
                const userChoice = confirm(`Would you like to open the device interface in this tab instead?\n\n${deviceUrl}`);
                if (userChoice) {
                    window.location.href = deviceUrl;
                }
            } else {
                // Log the access attempt
                fetch(`/api/devices/${deviceId}/log_access`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        action: 'remote_access_from_map',
                        timestamp: new Date().toISOString(),
                        url: deviceUrl,
                        connection_type: connectionType
                    })
                }).catch(err => console.log('Access logging failed:', err));
                
                // Show brief success feedback
                const originalContent = button.innerHTML;
                button.innerHTML = `<i class="fas fa-check"></i><span>Opened (${connectionType})</span>`;
                setTimeout(() => {
                    button.innerHTML = originalContent;
                }, 2000);
            }
        })
        .catch(error => {
            console.error('Error getting device connection info:', error);
            alert('âŒ Error determining connection method');
        });
}

// Recording status polling
let recordingStatusInterval;

function startRecordingStatusPolling() {
    // Clear any existing interval
    if (recordingStatusInterval) {
        clearInterval(recordingStatusInterval);
    }
    
    // Poll every 3 seconds for recording status
    recordingStatusInterval = setInterval(checkAllRecordingStatus, 3000);
    console.log('ðŸ“¹ Recording status polling started');
}

function checkAllRecordingStatus() {
    console.log(`ðŸ” Checking recording status for ${devices.length} devices:`, devices.map(d => d.device_id));
    
    // Check recording status for all devices
    devices.forEach(device => {
        console.log(`ðŸ“¹ About to check device ${device.device_id}`);
        checkDeviceRecordingStatus(device.device_id);
    });
}

function checkDeviceRecordingStatus(deviceId) {
    console.log(`ðŸ” Checking recording status for device ${deviceId}`);
    
    fetch(`/api/devices/${deviceId}/recording_status`)
        .then(response => response.json())
        .then(data => {
            console.log(`ðŸ“Š Device ${deviceId} recording status:`, data);
            
            if (data.success) {
                console.log(`Device ${deviceId}: is_recording=${data.is_recording}, motion_enabled=${data.motion_enabled}`);
                updateDeviceRecordingIndicator(deviceId, data.is_recording);
            } else {
                console.log(`âŒ Device ${deviceId} recording status failed:`, data.error);
            }
        })
        .catch(error => {
            console.error(`Recording status check failed for device ${deviceId}:`, error);
        });
}

function updateDeviceRecordingIndicator(deviceId, isRecording) {
    // Find the marker for this device
    const marker = markers.find(m => m.deviceId === deviceId);
    if (!marker) return;
    
    const markerElement = marker.getElement();
    if (!markerElement) return;
    
    if (isRecording) {
        // Add recording class for flashing effect
        markerElement.classList.add('recording');
        console.log(`ðŸ“¹ Device ${deviceId} is recording - showing flashing indicator`);
    } else {
        // Remove recording class
        markerElement.classList.remove('recording');
    }
}

// Add devices to map
const markers = [];
devices.forEach(device => {
    const status = (device.connection_status === 'connected' || device.tunnel_status === 'connected') ? 'connected' : 
               (device.approval_status === 'pending' ? 'pending' : 'disconnected');
    const icon = markerIcons[status] || markerIcons['disconnected'];
   
    const marker = L.marker([device.latitude, device.longitude], { icon: icon })
        .addTo(map)
        .bindPopup(createDevicePopup(device), {
            maxWidth: 320,
            className: 'device-popup'
        });
   
    // Store device ID for recording status updates
    marker.deviceId = device.device_id;
    markers.push(marker);
});

// Fit map to show all markers
if (markers.length > 0) {
    const group = new L.featureGroup(markers);
    map.fitBounds(group.getBounds().pad(0.1));
}

// Function to view device details (keeping your original function)
function viewDevice(deviceId) {
    window.location.href = `/devices/${deviceId}`;
}

console.log(`Map initialized with ${devices.length} devices`);

// Start polling after map is initialized
setTimeout(startRecordingStatusPolling, 2000); // Start after 2 seconds

// Stop polling when page is hidden, resume when visible
document.addEventListener('visibilitychange', function() {
    if (document.visibilityState === 'visible') {
        startRecordingStatusPolling();
    } else {
        if (recordingStatusInterval) {
            clearInterval(recordingStatusInterval);
        }
    }
});
</script>
{% endblock %}